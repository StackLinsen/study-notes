# 301-310

## 301期

> 问：什么是栈上分配？

解：有了逃逸分析，我们可以判断判断出一个方法的变量是否有可能被其他线程所访问或者改变，那么基于这个特性，JIT就可以做一些优化：

* 同步省略
* 标量替换
* 栈上分配

所谓栈上分配，就是将对象直接在栈上进行内存分配，但是由于技术还不成熟，HotSpot中，栈上分配并没有正在进行的实现，而是通过变量替换来实现的



## 302期

> 问：什么是标量替换？

解：标量(Scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量(Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

```java
public static void main(Stirng[] args){
    alloc();
}
private static void alloc(){
    Point point = new Point(1,2);
    System.out.println("point.x="+point.x+"point.y="+point.y);
}
class Point{
    private int x;
    private int y;
}
```

以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就不会直接创建Point对象，而是直接使用两个标量int x，int y来替代Point对象

```java
private static void alloc(){
    int x = 1;
    int y = 2;
    System.out.println("point.x="+x+"point.y="+y);
}
```

可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。

通过标量替换，原本的一个对象，被替换成了多个成员变量，而原本需要在堆上分配的内存，也就不再需要了，完全可以在本地方法栈中完成对成员变量的内存分配。

## 303期

> 问：虚拟机中的堆一定是线程共享的吗？

解：为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。

在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。

所以，“堆是线程共享的内存区域”这句话并不完全正确，因为TLAB是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分配上，是线程独享的。

TLAB的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配，那么，对象的内存分配步骤就是先尝试TLAB分配，空间不足后，再判断是否应该直接进入老年代，然后再确定是在eden分配还是在老年代分配。

## 304期

> 问：什么是TLAB

解：TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是线程专属的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率

所以说：因为有了TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。

这里值得注意的是，我们说TLAB是线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取，垃圾回收等动作上都是线程共享的，而且在使用上也没有什么区别。

也就是说，虽然每个线程在初始化时都会去堆内存中申请一块TLAB，并不是说这个TLAB区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。

并且，在TLAB分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space，Old Gen等。



## 305期

> 问：TLAB带来的问题？

解：虽然在一定程度上，TLAB大大的提升了对象的分配速度，但是TLAB并不是就没有任何问题的。

前面我们说过，因为TLAB内存区域并不是很大，所以，有可能会经常出现不够的情况。在《实战Java虚拟机》中有这样一个例子：

比如一个线程的TLAB空间有100KB，其中已经使用了80KB，当需要再分配一个30KB的对象时，就无法直接在TLAB中分配，遇到这种情况时，有两种处理方案：

1、如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则直接在堆内存中对该对象进行内存分配。

2、如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则废弃当前TLAB，重新申请TLAB空间再次进行内存分配。

以上两个方案各由利弊，如果采用方案1，那么就可能存在者一种极端情况，就是TLAB只剩下1KB，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。

如果采用方案2，也有可能存在频繁废弃TLAB，频繁申请TLAB的情况，而我们知道，虽然在TLAB上分配内存是线程独享的，但是TLAB内存自己从堆中划分出来的过程确实可能存在冲突的，所以，TLAB的分配过程其实需要并发控制的。而频繁的TLAB分配就失去了引入的意义

为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间”

当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配

前面的例子中，TLAB总空间100KB，使用了80KB，剩余20KB，如果设置的refill_waste的值为25KB，那么如果新对象的内存大于25KB，则直接堆内存分配，如果小于25KB，则会废弃掉之前的那个TLAB，重新分配一个TLAB空间，给新对象分配内存。

## 306期

> 问：TLAB和栈上分配的关系和区别？

解：二者其实并没有什么太大的关系，很多人爱拿两者来比较，是因为有一个误区，就是认为二者都是避免了对象在堆上分配。

其实这种想法是错的。TLAB并没有避免堆上分配内存，分配还是在堆上的，只不过是eden区中的一块特殊区域。而栈上分配才是避免了在堆上分配内存。

在内存分配过程中，会先尝试栈上分配，不满足要求的话，会进行TLAB分配，然后再进行正常分配的。

## 307期

> 问：什么是方法区？

解：在Java虚拟机中，方法区是可供线程共享的运行时内存区域，它存储了每一个类的结构信息，例如运行时常量池(Runtime Constant Pool)，字段和方法数据，构造函数和普通方法的字节码内容，还包括一些在类，实例，接口初始化时用到的特殊方法。

方法区在虚拟机启动的时候被创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集。

但是Java虚拟机规范也不限定方法区的内存位置和编译代码的管理策略。

方法区的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并不在需要过多空间自动收缩。

方法区在实际内存空间中可以是不连续的。Java虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大，最小容量的手段。

从这些描述可以看出来，其实在Java虚拟机规范中，对于方法区的要求还是比较宽松的，只要求他要随着JVM启动而创建，并且是线程共享的以及规定了其中保存的内容。

但是并没有规定他的具体实现方式，所以在不同的虚拟机类型，甚至不同的版本中实现方式也不尽相同。

## 308期

> 问：HotSpot虚拟机在JDK1.8以前中方法区是怎么实现的？

解：Java虚拟机规范中说：方法区在虚拟机启动的时候被创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集。

那么，HotSpot虚拟机为了实现方法区，提供了一块非堆区域，叫做永久代。

在HotSpot虚拟机中，按照内存用途将内存空间划分为堆和非堆。其中堆空间用于对象分配，根据对象的年龄，又可以划分为新生代和老年代。而非堆内存就包含了永久代(或者叫方法区)。

之所以起了一个和新生代，老年代类似的名字，我认为其实是为了说明这个区域也是可以被垃圾回收的。

永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小

所以，方法区是Java虚拟机规范中的定义，是一种规范。而永久代是HotSpot的一种实现，其他的虚拟机实现并没有永久代。

在JDK1.8之前的实现中。HotSpot使用永久代实现方法区，HotSpot使用GC分代来实现方法区内存回收。

## 309期

> 问：HotSpot虚拟机在JDK1.8之后，方法区是怎么实现的？

解：在JDK1.8之前的实现中，HotSpot使用永久代实现方法区，HotSpot使用GC分代来实现方法区内存回收。

HotSpot虚拟机在1.8之后已经移除了永久代，改为元空间，类的元信息被存储在元空间中。和永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的系统可用内存。

因为移除了永久代，所以方法区的实现自然就发生了变化，虚拟机规范中规定的方法区中存放的是一些描述信息，既元数据，这些元数据便不能存放在永久代了，就需要存放在JDK1.8提供的元空间中。

所以，在HotSpot虚拟机在JDK1.8以后，方法区是通过元空间实现的。

## 310期

> 问：什么是Class常量池？

解：在Java体系中，共有三种常量池，分别是字符串常量池，Class常量池和运行时常量池

- Class文件：Class文件中包含了Java虚拟机指令集和符号表以及若干其它辅助信息。

Class文件结构：

```
cafe babe   0000    0034      0011          0a00 0400 0d08。。。
魔数        次版本号  主版本号   常量池计数器    常量池数据区
```



- Class常量池：Class常量池可以理解为是Class文件中的资源仓库。Class文件中除了包含类的版本，字段，方法，接口等描述信息外，还有一项信息就是常量池（constant pool table），用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)
  - 字面量：在计算机科学中，字面量是用于表达源码中一个固定值的表示法(notation)，简单点说：字面量就是指由字母，数字等构成的字符串或者数值，字面量只可以右值出现
  - 符号引用：符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符
- Class常量池作用：Java代码在进行Javac编译的时候，是在虚拟机加载Class文件的时候进行动态链接。也就是说，在Class文件中不会保存各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机直接使用。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址之中。



# 311-320

## 311期

> 问：什么是运行时常量池

解：运行时常量池(Runtime Constant Pool)是每一个类或接口的常量池(Constant Pool)的运行时表示形式。

它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表(SymbolTable)的角色，不过它存储数据范围比通常意义上的符号表要更为广泛

每一个运行时常量池都分配在Java虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来



## 312期

> 问：运行时常量池，Class常量池，字符串常量池的区别与联系？

解：虚拟机启动过程中，会将各个Class文件中的常量池载入到运行时常量池中。

所以，Class常量池只是一个媒介场所。在JVM真的运行时，需要把常量池中的常量加载到内存中，进入到运行时常量池。

字符串常量池可以理解为运行时常量池分出来的部分。加载时，对于class的静态常量池，如字符串会被装到字符串常量池中。

## 313期

> 问：运行时常量池在JDK各个版本中的实现？

解：根据Java虚拟机规范约定：每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。

在不同版本的JDK中，运行时常量池所处的位置也不一样。以HotSpot为例：
在JDK1.7之前，方法区位于堆内存的永久代中。运行时常量池作为方法区的一部分，也处于永久代中。

因为使用永久代实现方法区可能导致内存泄漏问题，所以，从JDK1.7开始，JVM尝试解决这一问题，在1.7中，将原本位于永久代中的运行时常量池移动到堆内存中。(永久代在JDK1.7并没有完全移除，只是原来方法区中的运行时常量池，类的静态变量等移到了堆内存中。)

在JDK1.8中。彻底移除了永久代，方法区通过元空间的方式实现，随之，运行时常量池也在元空间中实现。



## 314期

> 问：运行时常量池中常量的来源？

解：运行时常量池中包含了若干种不同的常量：

编译期可知的字面量和符号引用(来自Class常量池)

运行期解析后可获得的常量(如String的inter方法)

所以，运行时常量池中的内容包含：Class常量池中的常量，字符串常量池中的内容

## 315期

> 问：什么是直接内存？

解：直接内存并不是虚拟机运行时数据区域的一部分，也不是Java虚拟机规范中定义的内存区域

但是这部分内容也至关重要并且经常被使用，并且也能导致OOM，
JDK1.4加入了新的NIO机制，目的是防止Java堆和Native堆之间往复的数据复制带来的性能损耗，此后NIO可以使用Native函数直接在堆外分配内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

直接内存区域是全局共享的内存区域，并且可以进行自动内存管理(GC)，但机制并不完善。

本机的Native堆(直接内存)不受JVM堆内存大小限制，但是受到本机总内存的大小以及处理器寻址空间的限制

## 316期

> 问：HotSpot的Java对象模型是什么？

解：HotSpot JVM设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。

每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。



## 317期

> 问：Java对象的内存布局是怎样的？

解：根据HotSpot虚拟机的OOP-Klass Model中，对象在内存中存储的布局可以分为三块区域：对象头，实例数据和对齐填充。

对象头包含了两部分内容：`_mark`和`_metadata`

**Mark Word**

对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间

对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。

**metaData**

这部分是类型指针，其中包含`_klass`和`_compredded_klass`，其中`_klass`是普通指针，`_compressed_klass`是压缩类指针。这两个指针都指向instanceKlass对象，它用来描述对象的具体类型。

## 318期

> 问：什么是STOP THE WORLD机制？

解：Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起(除了垃圾收集帮助器之外)。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。

不管选择哪种GC算法，stop-the-world都是不可避免的。

## 319期

> 问：Java中的四种引用类型

解：

强引用：如果一个对象具有强引用，那垃圾回收器不会回收它。

软引用：软引用不会保证对象一定不会被回收，只能最大可能保证。在内存不足时才会被回收    SoftReference

弱引用：如果一个对象只具有弱以用，无论内存充足与否，GC后都将被回收   WeakReference

虚引用：如果一个对象仅有虚引用，那么它就像没有任何引用一样，在任何时候都可能被gc回收。虚引用主要用来跟宗对象被垃圾回收的活动。



## 320期

> 问：如何判断一个对象Java对象能否被回收？

解：

引用计数法：循环引用，无法表示多种应用

可达性分析算法：通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时，则证明此对象时不可用的。

# 321-330

## 321期

> 问：Java中哪些对象可以作为GC Roots？

解：

1、在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等。

2、在方法区中类静态属性引用的对象，譬如Java类的应用类型静态变量

3、在方法区中常量应用的对象，譬如字符串池中的引用

4、在本地方法栈中JNI引用的对象

5、Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻异常对象(如NPE)，还有系统类加载器

6、所有被同步锁持有的对象

7、反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调，本地代码缓存等。



## 330期

> 问：简单说一说JVM类加载机制

解：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载**（Loading），**验证**（Verification），**准备**（Preparation），**解析**（Resoltion），**初始化**（Initialization），**使用**（Using）和**卸载**（Unloading）7个阶段。其中验证，准备，解析3个部分统称为**链接**（Linking）

加载，验证，准备，初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的**开始**，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的动态绑定。

注意：按部就班的开始，而不是按部就班的“进行”或者“完成”，强调这点是因为这些阶段通常都是互相交叉的混合式进行的，通常会在一个阶段执行的过程中调用，激活另外一个阶段。



## 331期

> 问：如何判断JVM中类和其它类是不是同一个类

解：类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间

简单点说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等



## 332期

> 问：Java中有哪几种类加载器

解：从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现(只限于HotSpot)，是虚拟机自身的一部分；

另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader.

从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到一下3种系统提供得类加载器。

**启动类加载器**（Bootstrap ClassLoader）：这个类加载器负责将存放在<JAVA_HOME>\lib目录中得，或者被-Xbootclasspath参数所指定得路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用(null)，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。

**扩展类加载器**（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器

**应用程序类加载器**（Application ClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器



## 333期

> 问：什么是双亲委派机制

解：图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般**不会以继承**（Inheritance）的关系来实现，而是都**使用组合**（Composition）关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载

双亲委派模型对于保证Java程序的稳定运作很重要，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法：先检查类是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器，如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。



## 334期

> 问：为什么需要双亲委派，不委派有什么问题

解：使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱



## 335期

> 问：如何破坏双亲委派？

解：自定义类加载器，重写其中的loadClass方法



## 336期

> 问：自定义类加载器，需要重写哪个方法

解：如果自定义的方法不想违背双亲委派模型，则只需要重写findClass方法即可

如果想违背双亲委派模型，则还需要重写loadClass()方法



## 337期

> 问：loadClass()，findClass()，defineClass()区别

解：**loadClass()**

findLoadedClass(String) 调用这个方法，查看这个Class是否已经呗加载，如果没有被加载，继续往下走，查看父类加载器，递归调用loadClass()，如果父类加载是null，说明是启动类加载器，查找对应的Class，如果都没有找到，就调用findClass(String)

**findClass()**

根据名称或位置加载.class字节码，然后使用defineClass通常由子类去实现

**defineClass()**

把字节码转化为Class



## 338期

> 问：类加载的过程是线程安全的嘛？

解：线程安全的，因为loadClass方法中，是被synchronized加了锁的



## 339期

> 问：Java类加载器基于哪三个机制？

解：**委托性**，**可见性**和**单一性**

1. 委托机制是指双亲委派模型
2. 可见性原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类
3. 单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类



## 340期

>问：Java类被加载之后会立即初始化嘛？什么时候初始化的？

解：不会被立即初始化，在发生下列行为时，类或接口将被初始化

	1.	在执行需要引用类或接口的Java虚拟机指令(new,getstatic,putstatic或invokestatic)时
 	2.	在初次调用java.lang.invoke.MethodHandle实例时
 	3.	在调用JDK核心类库中的反射方法时
 	4.	在对于类的某个子类的初始化
 	5.	在它被选定为Java虚拟机启动时的初始类时



## 341期

> 问：说一说你知道的双亲委派被破坏的例子

解：

1、**向前兼容**。由于双亲委派模型是在JDK1.2之后才被引入的，而类加载和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法

loadClassInternal(),而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这个就可以保证新写出来的类加载是符合双亲委派模型的。

2、JNDI，JDBC，JCE，JAXB和JBI等需要加载SPI接口实现类的情况

3、热部署。为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换

4、tomcat等web容器



## 342期

> 问：为什么JNDI，JDBC等需要破坏双亲委派

解：